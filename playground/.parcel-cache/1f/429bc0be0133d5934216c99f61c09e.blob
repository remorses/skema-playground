var $ce54f622a5f03b79dc45f6f0acf5$exports = {};
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "tslib");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "classnames");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "react");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "../../common/abstractPureComponent");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "../../common/classes");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "../../common/keys");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "../../common/props");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "../../common/utils");
$parcel$require("6675ce54f622a5f03b79dc45f6f0acf5", "./sliderUtils");
// props that require number values, for validation
var $ce54f622a5f03b79dc45f6f0acf5$var$NUMBER_PROPS = ["max", "min", "stepSize", "tickSize", "value"];
/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */

var $ce54f622a5f03b79dc45f6f0acf5$export$Handle =
/** @class */
function (_super) {
  $ce54f622a5f03b79dc45f6f0acf5$import$tslib_1.__extends(Handle, _super);

  function Handle() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      isMoving: false
    };
    _this.refHandlers = {
      handle: function (el) {
        return _this.handleElement = el;
      }
    };

    _this.beginHandleMovement = function (event) {
      document.addEventListener("mousemove", _this.handleHandleMovement);
      document.addEventListener("mouseup", _this.endHandleMovement);

      _this.setState({
        isMoving: true
      });

      _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));
    };

    _this.beginHandleTouchMovement = function (event) {
      document.addEventListener("touchmove", _this.handleHandleTouchMovement);
      document.addEventListener("touchend", _this.endHandleTouchMovement);
      document.addEventListener("touchcancel", _this.endHandleTouchMovement);

      _this.setState({
        isMoving: true
      });

      _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));
    };

    _this.endHandleMovement = function (event) {
      _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));
    };

    _this.endHandleTouchMovement = function (event) {
      _this.handleMoveEndedAt(_this.touchEventClientOffset(event));
    };

    _this.handleMoveEndedAt = function (clientPixel) {
      _this.removeDocumentEventListeners();

      _this.setState({
        isMoving: false
      }); // always invoke onRelease; changeValue may call onChange if value is different


      var onRelease = _this.props.onRelease;

      var finalValue = _this.changeValue(_this.clientToValue(clientPixel));

      $ce54f622a5f03b79dc45f6f0acf5$import$safeInvoke(onRelease, finalValue);
    };

    _this.handleHandleMovement = function (event) {
      _this.handleMovedTo(_this.mouseEventClientOffset(event));
    };

    _this.handleHandleTouchMovement = function (event) {
      _this.handleMovedTo(_this.touchEventClientOffset(event));
    };

    _this.handleMovedTo = function (clientPixel) {
      if (_this.state.isMoving && !_this.props.disabled) {
        _this.changeValue(_this.clientToValue(clientPixel));
      }
    };

    _this.handleKeyDown = function (event) {
      var _a = _this.props,
          stepSize = _a.stepSize,
          value = _a.value;
      var which = event.which;

      if (which === $ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_DOWN || which === $ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_LEFT) {
        _this.changeValue(value - stepSize); // this key event has been handled! prevent browser scroll on up/down


        event.preventDefault();
      } else if (which === $ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_UP || which === $ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_RIGHT) {
        _this.changeValue(value + stepSize);

        event.preventDefault();
      }
    };

    _this.handleKeyUp = function (event) {
      if ([$ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_UP, $ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_DOWN, $ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_LEFT, $ce54f622a5f03b79dc45f6f0acf5$import$Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {
        $ce54f622a5f03b79dc45f6f0acf5$import$safeInvoke(_this.props.onRelease, _this.props.value);
      }
    };

    return _this;
  }

  Handle.prototype.componentDidMount = function () {
    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.
    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.
    this.forceUpdate();
  };

  Handle.prototype.render = function () {
    var _a = this.props,
        className = _a.className,
        disabled = _a.disabled,
        label = _a.label,
        min = _a.min,
        tickSizeRatio = _a.tickSizeRatio,
        value = _a.value,
        vertical = _a.vertical;
    var isMoving = this.state.isMoving; // The handle midpoint of RangeSlider is actually shifted by a margin to
    // be on the edge of the visible handle element. Because the midpoint
    // calculation does not take this margin into account, we instead
    // measure the long side (which is equal to the short side plus the
    // margin).

    var handleMidpoint = this.getHandleMidpointAndOffset(this.handleElement, true).handleMidpoint;
    var offsetRatio = (value - min) * tickSizeRatio;
    var offsetCalc = "calc(" + $ce54f622a5f03b79dc45f6f0acf5$import$formatPercentage(offsetRatio) + " - " + handleMidpoint + "px)";
    var style = vertical ? {
      bottom: offsetCalc
    } : {
      left: offsetCalc
    };
    return $ce54f622a5f03b79dc45f6f0acf5$import$React.createElement("span", {
      className: $ce54f622a5f03b79dc45f6f0acf5$import$classNames($ce54f622a5f03b79dc45f6f0acf5$import$Classes.SLIDER_HANDLE, (_b = {}, _b[$ce54f622a5f03b79dc45f6f0acf5$import$Classes.ACTIVE] = isMoving, _b), className),
      onKeyDown: disabled ? null : this.handleKeyDown,
      onKeyUp: disabled ? null : this.handleKeyUp,
      onMouseDown: disabled ? null : this.beginHandleMovement,
      onTouchStart: disabled ? null : this.beginHandleTouchMovement,
      ref: this.refHandlers.handle,
      style: style,
      tabIndex: 0
    }, label == null ? null : $ce54f622a5f03b79dc45f6f0acf5$import$React.createElement("span", {
      className: $ce54f622a5f03b79dc45f6f0acf5$import$Classes.SLIDER_LABEL
    }, label));

    var _b;
  };

  Handle.prototype.componentWillUnmount = function () {
    this.removeDocumentEventListeners();
  };
  /** Convert client pixel to value between min and max. */


  Handle.prototype.clientToValue = function (clientPixel) {
    var _a = this.props,
        stepSize = _a.stepSize,
        tickSize = _a.tickSize,
        value = _a.value,
        vertical = _a.vertical;

    if (this.handleElement == null) {
      return value;
    } // #1769: this logic doesn't work perfectly when the tick size is
    // smaller than the handle size; it may be off by a tick or two.


    var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;
    var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);
    var pixelDelta = clientPixelNormalized - handleCenterPixel;

    if (isNaN(pixelDelta)) {
      return value;
    } // convert pixels to range value in increments of `stepSize`


    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;
  };

  Handle.prototype.mouseEventClientOffset = function (event) {
    return this.props.vertical ? event.clientY : event.clientX;
  };

  Handle.prototype.touchEventClientOffset = function (event) {
    var touch = event.changedTouches[0];
    return this.props.vertical ? touch.clientY : touch.clientX;
  };

  Handle.prototype.validateProps = function (props) {
    for (var _i = 0, NUMBER_PROPS_1 = $ce54f622a5f03b79dc45f6f0acf5$var$NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {
      var prop = NUMBER_PROPS_1[_i];

      if (typeof props[prop] !== "number") {
        throw new Error("[Blueprint] <Handle> requires number value for " + prop + " prop");
      }
    }
  };
  /** Clamp value and invoke callback if it differs from current value */


  Handle.prototype.changeValue = function (newValue, callback) {
    if (callback === void 0) {
      callback = this.props.onChange;
    }

    newValue = this.clamp(newValue);

    if (!isNaN(newValue) && this.props.value !== newValue) {
      $ce54f622a5f03b79dc45f6f0acf5$import$safeInvoke(callback, newValue);
    }

    return newValue;
  };
  /** Clamp value between min and max props */


  Handle.prototype.clamp = function (value) {
    return $ce54f622a5f03b79dc45f6f0acf5$import$clamp(value, this.props.min, this.props.max);
  };

  Handle.prototype.getHandleElementCenterPixel = function (handleElement) {
    var _a = this.getHandleMidpointAndOffset(handleElement),
        handleMidpoint = _a.handleMidpoint,
        handleOffset = _a.handleOffset;

    return handleOffset + handleMidpoint;
  };

  Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {
    if (useOppositeDimension === void 0) {
      useOppositeDimension = false;
    }

    if (handleElement == null) {
      return {
        handleMidpoint: 0,
        handleOffset: 0
      };
    }

    var vertical = this.props.vertical; // getBoundingClientRect().height includes border size; clientHeight does not.

    var handleRect = handleElement.getBoundingClientRect();
    var sizeKey = vertical ? useOppositeDimension ? "width" : "height" : useOppositeDimension ? "height" : "width"; // "bottom" value seems to be consistently incorrect, so explicitly
    // calculate it using the window offset instead.

    var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;
    return {
      handleMidpoint: handleRect[sizeKey] / 2,
      handleOffset: handleOffset
    };
  };

  Handle.prototype.removeDocumentEventListeners = function () {
    document.removeEventListener("mousemove", this.handleHandleMovement);
    document.removeEventListener("mouseup", this.endHandleMovement);
    document.removeEventListener("touchmove", this.handleHandleTouchMovement);
    document.removeEventListener("touchend", this.endHandleTouchMovement);
    document.removeEventListener("touchcancel", this.endHandleTouchMovement);
  };

  Handle.displayName = $ce54f622a5f03b79dc45f6f0acf5$import$DISPLAYNAME_PREFIX + ".SliderHandle";
  return Handle;
}($ce54f622a5f03b79dc45f6f0acf5$import$AbstractPureComponent);

$ce54f622a5f03b79dc45f6f0acf5$exports.Handle = $ce54f622a5f03b79dc45f6f0acf5$export$Handle;