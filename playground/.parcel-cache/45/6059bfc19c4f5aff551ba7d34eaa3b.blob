var $c442ed6b3390424e42023c3db1e7f41$var$_temp,
    $c442ed6b3390424e42023c3db1e7f41$exports = {};
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "tslib");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "classnames");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "react");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "../../common/boundary");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "../../common/classes");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "../../common/errors");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "../../common/props");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "../../common/utils");
$parcel$require("3c442ed6b3390424e42023c3db1e7f41", "../resize-sensor/resizeSensor");

/** @internal - do not expose this type */
var $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection;
$c442ed6b3390424e42023c3db1e7f41$exports.OverflowDirection = $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection;

(function (OverflowDirection) {
  OverflowDirection[OverflowDirection["NONE"] = 0] = "NONE";
  OverflowDirection[OverflowDirection["GROW"] = 1] = "GROW";
  OverflowDirection[OverflowDirection["SHRINK"] = 2] = "SHRINK";
})($c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection || ($c442ed6b3390424e42023c3db1e7f41$var$_temp = $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection = {}, $c442ed6b3390424e42023c3db1e7f41$exports.OverflowDirection = $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection, $c442ed6b3390424e42023c3db1e7f41$var$_temp));

var $c442ed6b3390424e42023c3db1e7f41$export$OverflowList =
/** @class */
function (_super) {
  $c442ed6b3390424e42023c3db1e7f41$import$tslib_1.__extends(OverflowList, _super);

  function OverflowList() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      direction: $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.NONE,
      lastOverflowCount: 0,
      overflow: [],
      visible: _this.props.items
    };
    /** A cache containing the widths of all elements being observed to detect growing/shrinking */

    _this.previousWidths = new Map();
    _this.spacer = null;

    _this.resize = function (entries) {
      // if any parent is growing, assume we have more room than before
      var growing = entries.some(function (entry) {
        var previousWidth = _this.previousWidths.get(entry.target) || 0;
        return entry.contentRect.width > previousWidth;
      });

      _this.repartition(growing);

      entries.forEach(function (entry) {
        return _this.previousWidths.set(entry.target, entry.contentRect.width);
      });
    };

    return _this;
  }

  OverflowList.ofType = function () {
    return OverflowList;
  };

  OverflowList.prototype.componentDidMount = function () {
    this.repartition(false);
  };

  OverflowList.prototype.componentWillReceiveProps = function (nextProps) {
    var _a = this.props,
        collapseFrom = _a.collapseFrom,
        items = _a.items,
        minVisibleItems = _a.minVisibleItems,
        observeParents = _a.observeParents,
        overflowRenderer = _a.overflowRenderer,
        visibleItemRenderer = _a.visibleItemRenderer;

    if (observeParents !== nextProps.observeParents) {
      console.warn($c442ed6b3390424e42023c3db1e7f41$import$OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);
    }

    if (collapseFrom !== nextProps.collapseFrom || items !== nextProps.items || minVisibleItems !== nextProps.minVisibleItems || overflowRenderer !== nextProps.overflowRenderer || visibleItemRenderer !== nextProps.visibleItemRenderer) {
      // reset visible state if the above props change.
      this.setState({
        direction: $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.GROW,
        lastOverflowCount: 0,
        overflow: [],
        visible: nextProps.items
      });
    }
  };

  OverflowList.prototype.shouldComponentUpdate = function (_nextProps, nextState) {
    // We want this component to always re-render, even when props haven't changed, so that
    // changes in the renderers' behavior can be reflected.
    // The following statement prevents re-rendering only in the case where the state changes
    // identity (i.e. setState was called), but the state is still the same when
    // shallow-compared to the previous state.
    return !(this.state !== nextState && $c442ed6b3390424e42023c3db1e7f41$import$shallowCompareKeys(this.state, nextState));
  };

  OverflowList.prototype.componentDidUpdate = function (_prevProps, prevState) {
    if (!$c442ed6b3390424e42023c3db1e7f41$import$shallowCompareKeys(prevState, this.state)) {
      this.repartition(false);
    }

    var _a = this.state,
        direction = _a.direction,
        overflow = _a.overflow,
        lastOverflowCount = _a.lastOverflowCount;

    if ( // if a resize operation has just completed (transition to NONE)
    direction === $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.NONE && direction !== prevState.direction && overflow.length !== lastOverflowCount) {
      $c442ed6b3390424e42023c3db1e7f41$import$safeInvoke(this.props.onOverflow, overflow);
    }
  };

  OverflowList.prototype.render = function () {
    var _this = this;

    var _a = this.props,
        className = _a.className,
        collapseFrom = _a.collapseFrom,
        observeParents = _a.observeParents,
        style = _a.style,
        _b = _a.tagName,
        TagName = _b === void 0 ? "div" : _b,
        visibleItemRenderer = _a.visibleItemRenderer;
    var overflow = this.maybeRenderOverflow();
    return $c442ed6b3390424e42023c3db1e7f41$import$React.createElement($c442ed6b3390424e42023c3db1e7f41$import$ResizeSensor, {
      onResize: this.resize,
      observeParents: observeParents
    }, $c442ed6b3390424e42023c3db1e7f41$import$React.createElement(TagName, {
      className: $c442ed6b3390424e42023c3db1e7f41$import$classNames($c442ed6b3390424e42023c3db1e7f41$import$Classes.OVERFLOW_LIST, className),
      style: style
    }, collapseFrom === $c442ed6b3390424e42023c3db1e7f41$import$Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === $c442ed6b3390424e42023c3db1e7f41$import$Boundary.END ? overflow : null, $c442ed6b3390424e42023c3db1e7f41$import$React.createElement("div", {
      className: $c442ed6b3390424e42023c3db1e7f41$import$Classes.OVERFLOW_LIST_SPACER,
      ref: function (ref) {
        return _this.spacer = ref;
      }
    })));
  };

  OverflowList.prototype.maybeRenderOverflow = function () {
    var overflow = this.state.overflow;

    if (overflow.length === 0) {
      return null;
    }

    return this.props.overflowRenderer(overflow);
  };

  OverflowList.prototype.repartition = function (growing) {
    var _this = this;

    if (this.spacer == null) {
      return;
    }

    if (growing) {
      this.setState(function (state) {
        return {
          direction: $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.GROW,
          // store last overflow if this is the beginning of a resize (for check in componentDidUpdate).
          lastOverflowCount: state.direction === $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.NONE ? state.overflow.length : state.lastOverflowCount,
          overflow: [],
          visible: _this.props.items
        };
      });
    } else if (this.spacer.getBoundingClientRect().width < 0.9) {
      // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink
      this.setState(function (state) {
        if (state.visible.length <= _this.props.minVisibleItems) {
          return null;
        }

        var collapseFromStart = _this.props.collapseFrom === $c442ed6b3390424e42023c3db1e7f41$import$Boundary.START;
        var visible = state.visible.slice();
        var next = collapseFromStart ? visible.shift() : visible.pop();

        if (next === undefined) {
          return null;
        }

        var overflow = collapseFromStart ? state.overflow.concat([next]) : [next].concat(state.overflow);
        return {
          // set SHRINK mode unless a GROW is already in progress.
          // GROW shows all items then shrinks until it settles, so we
          // preserve the fact that the original trigger was a GROW.
          direction: state.direction === $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.NONE ? $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.SHRINK : state.direction,
          overflow: overflow,
          visible: visible
        };
      });
    } else {
      // repartition complete!
      this.setState({
        direction: $c442ed6b3390424e42023c3db1e7f41$export$OverflowDirection.NONE
      });
    }
  };

  OverflowList.displayName = $c442ed6b3390424e42023c3db1e7f41$import$DISPLAYNAME_PREFIX + ".OverflowList";
  OverflowList.defaultProps = {
    collapseFrom: $c442ed6b3390424e42023c3db1e7f41$import$Boundary.START,
    minVisibleItems: 0
  };
  return OverflowList;
}($c442ed6b3390424e42023c3db1e7f41$import$React.Component);

$c442ed6b3390424e42023c3db1e7f41$exports.OverflowList = $c442ed6b3390424e42023c3db1e7f41$export$OverflowList;