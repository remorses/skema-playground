var $ed7604ff8b56121bd9b9f83e77c$exports = {};
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "tslib");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "classnames");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "react");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "react-dom");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "../../common/abstractPureComponent");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "../../common/classes");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "../../common/position");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "../../common/utils");
$parcel$require("23582ed7604ff8b56121bd9b9f83e77c", "../popover/popover");
var $ed7604ff8b56121bd9b9f83e77c$var$POPPER_MODIFIERS = {
  preventOverflow: {
    boundariesElement: "viewport"
  }
};
var $ed7604ff8b56121bd9b9f83e77c$var$TRANSITION_DURATION = 100;
/* istanbul ignore next */

var $ed7604ff8b56121bd9b9f83e77c$var$ContextMenu =
/** @class */
function (_super) {
  $ed7604ff8b56121bd9b9f83e77c$import$tslib_1.__extends(ContextMenu, _super);

  function ContextMenu() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.state = {
      isDarkTheme: false,
      isOpen: false,
      menu: null,
      offset: null
    };

    _this.cancelContextMenu = function (e) {
      return e.preventDefault();
    };

    _this.handleBackdropContextMenu = function (e) {
      // React function to remove from the event pool, useful when using a event within a callback
      e.persist();
      e.preventDefault(); // wait for backdrop to disappear so we can find the "real" element at event coordinates.
      // timeout duration is equivalent to transition duration so we know it's animated out.

      _this.setTimeout(function () {
        // retrigger context menu event at the element beneath the backdrop.
        // if it has a `contextmenu` event handler then it'll be invoked.
        // if it doesn't, no native menu will show (at least on OSX) :(
        var newTarget = document.elementFromPoint(e.clientX, e.clientY);
        newTarget.dispatchEvent(new MouseEvent("contextmenu", e));
      }, $ed7604ff8b56121bd9b9f83e77c$var$TRANSITION_DURATION);
    };

    _this.handlePopoverInteraction = function (nextOpenState) {
      if (!nextOpenState) {
        // delay the actual hiding till the event queue clears
        // to avoid flicker of opening twice
        requestAnimationFrame(function () {
          return _this.hide();
        });
      }
    };

    return _this;
  }

  ContextMenu.prototype.render = function () {
    // prevent right-clicking in a context menu
    var content = $ed7604ff8b56121bd9b9f83e77c$import$React.createElement("div", {
      onContextMenu: this.cancelContextMenu
    }, this.state.menu);
    var popoverClassName = $ed7604ff8b56121bd9b9f83e77c$import$classNames((_a = {}, _a[$ed7604ff8b56121bd9b9f83e77c$import$Classes.DARK] = this.state.isDarkTheme, _a)); // HACKHACK: workaround until we have access to Popper#scheduleUpdate().
    // https://github.com/palantir/blueprint/issues/692
    // Generate key based on offset so a new Popover instance is created
    // when offset changes, to force recomputing position.

    var key = this.state.offset == null ? "" : this.state.offset.left + "x" + this.state.offset.top; // wrap the popover in a positioned div to make sure it is properly
    // offset on the screen.

    return $ed7604ff8b56121bd9b9f83e77c$import$React.createElement("div", {
      className: $ed7604ff8b56121bd9b9f83e77c$import$Classes.CONTEXT_MENU_POPOVER_TARGET,
      style: this.state.offset
    }, $ed7604ff8b56121bd9b9f83e77c$import$React.createElement($ed7604ff8b56121bd9b9f83e77c$import$Popover, $ed7604ff8b56121bd9b9f83e77c$import$tslib_1.__assign({}, this.props, {
      backdropProps: {
        onContextMenu: this.handleBackdropContextMenu
      },
      content: content,
      enforceFocus: false,
      key: key,
      hasBackdrop: true,
      isOpen: this.state.isOpen,
      minimal: true,
      modifiers: $ed7604ff8b56121bd9b9f83e77c$var$POPPER_MODIFIERS,
      onInteraction: this.handlePopoverInteraction,
      position: $ed7604ff8b56121bd9b9f83e77c$import$Position.RIGHT_TOP,
      popoverClassName: popoverClassName,
      target: $ed7604ff8b56121bd9b9f83e77c$import$React.createElement("div", null),
      transitionDuration: $ed7604ff8b56121bd9b9f83e77c$var$TRANSITION_DURATION
    })));

    var _a;
  };

  ContextMenu.prototype.show = function (menu, offset, onClose, isDarkTheme) {
    this.setState({
      isOpen: true,
      menu: menu,
      offset: offset,
      onClose: onClose,
      isDarkTheme: isDarkTheme
    });
  };

  ContextMenu.prototype.hide = function () {
    $ed7604ff8b56121bd9b9f83e77c$import$safeInvoke(this.state.onClose);
    this.setState({
      isOpen: false,
      onClose: undefined
    });
  };

  return ContextMenu;
}($ed7604ff8b56121bd9b9f83e77c$import$AbstractPureComponent);

var $ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement;
var $ed7604ff8b56121bd9b9f83e77c$var$contextMenu;
/**
 * Show the given menu element at the given offset from the top-left corner of the viewport.
 * The menu will appear below-right of this point and will flip to below-left if there is not enough
 * room onscreen. The optional callback will be invoked when this menu closes.
 */

function $ed7604ff8b56121bd9b9f83e77c$export$show(menu, offset, onClose, isDarkTheme) {
  if ($ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement == null) {
    $ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement = document.createElement("div");
    $ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement.classList.add($ed7604ff8b56121bd9b9f83e77c$import$Classes.CONTEXT_MENU);
    document.body.appendChild($ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement);
    $ed7604ff8b56121bd9b9f83e77c$var$contextMenu = $ed7604ff8b56121bd9b9f83e77c$import$ReactDOM.render($ed7604ff8b56121bd9b9f83e77c$import$React.createElement($ed7604ff8b56121bd9b9f83e77c$var$ContextMenu, {
      onClosed: $ed7604ff8b56121bd9b9f83e77c$var$remove
    }), $ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement);
  }

  $ed7604ff8b56121bd9b9f83e77c$var$contextMenu.show(menu, offset, onClose, isDarkTheme);
}
/** Hide the open context menu. */


$ed7604ff8b56121bd9b9f83e77c$exports.show = $ed7604ff8b56121bd9b9f83e77c$export$show;

function $ed7604ff8b56121bd9b9f83e77c$export$hide() {
  if ($ed7604ff8b56121bd9b9f83e77c$var$contextMenu != null) {
    $ed7604ff8b56121bd9b9f83e77c$var$contextMenu.hide();
  }
}
/** Return whether a context menu is currently open. */


$ed7604ff8b56121bd9b9f83e77c$exports.hide = $ed7604ff8b56121bd9b9f83e77c$export$hide;

function $ed7604ff8b56121bd9b9f83e77c$export$isOpen() {
  return $ed7604ff8b56121bd9b9f83e77c$var$contextMenu != null && $ed7604ff8b56121bd9b9f83e77c$var$contextMenu.state.isOpen;
}

$ed7604ff8b56121bd9b9f83e77c$exports.isOpen = $ed7604ff8b56121bd9b9f83e77c$export$isOpen;

function $ed7604ff8b56121bd9b9f83e77c$var$remove() {
  if ($ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement != null) {
    $ed7604ff8b56121bd9b9f83e77c$import$ReactDOM.unmountComponentAtNode($ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement);
    $ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement.remove();
    $ed7604ff8b56121bd9b9f83e77c$var$contextMenuElement = null;
    $ed7604ff8b56121bd9b9f83e77c$var$contextMenu = null;
  }
} //# sourceMappingURL=contextMenu.js.map